From bc75b7b14324a78be279ee29563b3eeb7cb2aea3 Mon Sep 17 00:00:00 2001
From: Rob Browning <rlb@defaultvalue.org>
Date: Mon, 4 Apr 2011 22:46:35 -0500
Subject: use-safe-alloca-lisp-in-let-eval-apply-apply_lambda.diff
 * An allocation problem has been fixed in let, eval, apply, and apply_lambda.
   Patch: use-safe-alloca-lisp-in-let-eval-apply-apply_lambda.diff
   Provided-by: Sven Joachim <svenjoac@gmx.de>
   Date: Thu, 19 Aug 2010 21:24:11 +0200
   Added-by: Rob Browning <rlb@defaultvalue.org>
   Status: incorporated upstream

  Previously, the content of the relevant items was invisible to the
  garbage collector.

  The Debian patch is taken from this upstream commit:

  revno: 99983
  committer: Andreas Schwab <schwab@linux-m68k.org>
  branch nick: emacs
  timestamp: Tue 2010-08-17 23:07:50 +0200
  message:
    * eval.c (Flet, Feval, Fapply, apply_lambda): Use SAFE_ALLOCA_LISP
    instead of SAFE_ALLOCA.
---
 src/ChangeLog |    5 +++++
 src/eval.c    |   14 +++++---------
 2 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index ba78f95..f5c73db 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,3 +1,8 @@
+2010-08-17  Andreas Schwab  <schwab@linux-m68k.org>
+
+	* eval.c (Flet, Feval, Fapply, apply_lambda): Use SAFE_ALLOCA_LISP
+	instead of SAFE_ALLOCA.
+
 2010-08-17  Chong Yidong  <cyd@stupidchicken.com>
 
        * eval.c (Flet, Feval, Fapply, apply_lambda): Use SAFE_ALLOCA
diff --git a/src/eval.c b/src/eval.c
index 7bd27a0..6b74f5b 100644
--- a/src/eval.c
+++ b/src/eval.c
@@ -1034,7 +1034,7 @@ usage: (let VARLIST BODY...)  */)
 
   /* Make space to hold the values to give the bound variables */
   elt = Flength (varlist);
-  SAFE_ALLOCA (temps, Lisp_Object *, XFASTINT (elt) * sizeof (Lisp_Object));
+  SAFE_ALLOCA_LISP (temps, XFASTINT (elt));
 
   /* Compute the values and store them in `temps' */
 
@@ -2303,8 +2303,7 @@ DEFUN ("eval", Feval, Seval, 1, 1, 0,
 	  register int argnum = 0;
 	  USE_SAFE_ALLOCA;
 
-	  SAFE_ALLOCA (vals, Lisp_Object *,
-		       XINT (numargs) * sizeof (Lisp_Object));
+	  SAFE_ALLOCA_LISP (vals, XINT (numargs));
 
 	  GCPRO3 (args_left, fun, fun);
 	  gcpro3.var = vals;
@@ -2476,8 +2475,7 @@ usage: (apply FUNCTION &rest ARGUMENTS)  */)
 	{
 	  /* Avoid making funcall cons up a yet another new vector of arguments
 	     by explicitly supplying nil's for optional values */
-	  SAFE_ALLOCA (funcall_args, Lisp_Object *,
-		       (1 + XSUBR (fun)->max_args) * sizeof (Lisp_Object));
+	  SAFE_ALLOCA_LISP (funcall_args, 1 + XSUBR (fun)->max_args);
 	  for (i = numargs; i < XSUBR (fun)->max_args;)
 	    funcall_args[++i] = Qnil;
 	  GCPRO1 (*funcall_args);
@@ -2489,8 +2487,7 @@ usage: (apply FUNCTION &rest ARGUMENTS)  */)
      function itself as well as its arguments.  */
   if (!funcall_args)
     {
-      SAFE_ALLOCA (funcall_args, Lisp_Object *,
-		   (1 + numargs) * sizeof (Lisp_Object));
+      SAFE_ALLOCA_LISP (funcall_args, 1 + numargs);
       GCPRO1 (*funcall_args);
       gcpro1.nvars = 1 + numargs;
     }
@@ -3121,8 +3118,7 @@ apply_lambda (fun, args, eval_flag)
   USE_SAFE_ALLOCA;
 
   numargs = Flength (args);
-  SAFE_ALLOCA (arg_vector, Lisp_Object *,
-	       XINT (numargs) * sizeof (Lisp_Object));
+  SAFE_ALLOCA_LISP (arg_vector, XINT (numargs));
   args_left = args;
 
   GCPRO3 (*arg_vector, args_left, fun);
-- 
1.7.4.1

