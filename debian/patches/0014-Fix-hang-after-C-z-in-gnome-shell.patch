From 847d5d949a989ad15308ab56ec8a9ec7fd2dc2d1 Mon Sep 17 00:00:00 2001
From: Jan D <jan.h.d@swipnet.se>
Date: Sun, 30 Oct 2011 18:17:48 +0100
Subject: Fix hang after C-z in gnome-shell.

Emacs should no longer hang when C-z is pressed within the Gnome
shell.

Applied-By: Rob Browning <rlb@defaultvalue.org>
Origin: upstream, commit: d3b65adf905c408aea986ff113cb3bc1b24d73e9
Bug-Debian: http://bugs.debian.org/655592
---
 src/ChangeLog | 13 +++++++++++++
 src/xterm.c   | 45 +++++++++++++++++++++++++++++++++------------
 src/xterm.h   |  3 ++-
 3 files changed, 48 insertions(+), 13 deletions(-)

diff --git a/src/ChangeLog b/src/ChangeLog
index e44ec5fde6b..e1f24d19a6e 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -90,6 +90,19 @@
 	(xmenu_show, xdialog_show): Use it in record_unwind_protect instead of
 	calling free_menubar_widget_value_tree directly (Bug#9830).
 
+2011-10-30  Jan Dj√§rv  <jan.h.d@swipnet.se>
+
+	* xterm.h (x_display_info): Add Xatom_net_wm_state_hidden (Bug#9893).
+
+	* xterm.c: Declare x_handle_net_wm_state to return int.
+	(handle_one_xevent): Check if we are iconified but don't have
+	_NET_WM_STATE_HIDDEN.  If do, treat as deiconify (Bug#9893).
+	(get_current_wm_state): Return non-zero if not hidden,
+	check for _NET_WM_STATE_HIDDEN (Bug#9893).
+	(do_ewmh_fullscreen): Ignore return value from get_current_wm_state.
+	(x_handle_net_wm_state): Return what get_current_wm_state returns.
+	(x_term_init): Initialize dpyinfo->Xatom_net_wm_state_hidden.
+
 2011-09-19  Andreas Schwab  <schwab@linux-m68k.org>
 
 	* keymap.c (Fsingle_key_description): Use make_specified_string
diff --git a/src/xterm.c b/src/xterm.c
index af8af50298d..866915a9865 100644
--- a/src/xterm.c
+++ b/src/xterm.c
@@ -375,7 +375,7 @@ static void x_scroll_bar_report_motion P_ ((struct frame **, Lisp_Object *,
 					    enum scroll_bar_part *,
 					    Lisp_Object *, Lisp_Object *,
 					    unsigned long *));
-static void x_handle_net_wm_state P_ ((struct frame *, XPropertyEvent *));
+static int x_handle_net_wm_state P_ ((struct frame *, XPropertyEvent *));
 static void x_check_fullscreen P_ ((struct frame *));
 static void x_check_expected_move P_ ((struct frame *, int, int));
 static void x_sync_with_move P_ ((struct frame *, int, int, int));
@@ -6148,7 +6148,19 @@ handle_one_xevent (dpyinfo, eventp, finish, hold_quit)
       last_user_time = event.xproperty.time;
       f = x_top_window_to_frame (dpyinfo, event.xproperty.window);
       if (f && event.xproperty.atom == dpyinfo->Xatom_net_wm_state)
-        x_handle_net_wm_state (f, &event.xproperty);
+        if (x_handle_net_wm_state (f, &event.xproperty) && f->iconified)
+          {
+            /* Gnome shell does not iconify us when C-z is pressed.  It hides
+               the frame.  So if our state says we aren't hidden anymore,
+               treat is as deiconfied.  */
+            if (! f->async_iconified)
+              SET_FRAME_GARBAGED (f);
+            f->async_visible = 1;
+            f->async_iconified = 0;
+            f->output_data.x->has_been_visible = 1;
+            inev.ie.kind = DEICONIFY_EVENT;
+            XSETFRAME (inev.ie.frame_or_window, f);
+          }
 
       x_handle_property_notify (&event.xproperty);
       xft_settings_event (dpyinfo, &event);
@@ -8600,17 +8612,19 @@ x_set_sticky (f, new_value, old_value)
 
 /* Return the current _NET_WM_STATE.
    SIZE_STATE is set to one of the FULLSCREEN_* values.
-   STICKY is set to 1 if the sticky state is set, 0 if not.  */
+   STICKY is set to 1 if the sticky state is set, 0 if not.
 
-static void
-get_current_vm_state (struct frame *f,
+   Return non-zero if we are not hidden, zero if we are.  */
+
+static int
+get_current_wm_state (struct frame *f,
                       Window window,
                       int *size_state,
                       int *sticky)
 {
   Atom actual_type;
   unsigned long actual_size, bytes_remaining;
-  int i, rc, actual_format;
+  int i, rc, actual_format, is_hidden = 0;
   struct x_display_info *dpyinfo = FRAME_X_DISPLAY_INFO (f);
   long max_len = 65536;
   Display *dpy = FRAME_X_DISPLAY (f);
@@ -8632,7 +8646,7 @@ get_current_vm_state (struct frame *f,
       if (tmp_data) XFree (tmp_data);
       x_uncatch_errors ();
       UNBLOCK_INPUT;
-      return;
+      return ! f->iconified;
     }
 
   x_uncatch_errors ();
@@ -8640,7 +8654,9 @@ get_current_vm_state (struct frame *f,
   for (i = 0; i < actual_size; ++i)
     {
       Atom a = ((Atom*)tmp_data)[i];
-      if (a == dpyinfo->Xatom_net_wm_state_maximized_horz) 
+      if (a == dpyinfo->Xatom_net_wm_state_hidden)
+        is_hidden = 1;
+      else if (a == dpyinfo->Xatom_net_wm_state_maximized_horz)
         {
           if (*size_state == FULLSCREEN_HEIGHT)
             *size_state = FULLSCREEN_MAXIMIZED;
@@ -8662,6 +8678,7 @@ get_current_vm_state (struct frame *f,
 
   if (tmp_data) XFree (tmp_data);
   UNBLOCK_INPUT;
+  return ! is_hidden;
 }
 
 /* Do fullscreen as specified in extended window manager hints */
@@ -8674,7 +8691,7 @@ do_ewmh_fullscreen (f)
   Lisp_Object lval = get_frame_param (f, Qfullscreen);
   int cur, dummy;
 
-  get_current_vm_state (f, FRAME_OUTER_WINDOW (f), &cur, &dummy);
+  (void)get_current_wm_state (f, FRAME_OUTER_WINDOW (f), &cur, &dummy);
 
   /* Some window managers don't say they support _NET_WM_STATE, but they do say
      they support _NET_WM_STATE_FULLSCREEN.  Try that also.  */
@@ -8748,7 +8765,7 @@ XTfullscreen_hook (f)
 }
 
 
-static void
+static int
 x_handle_net_wm_state (f, event)
      struct frame *f;
      XPropertyEvent *event;
@@ -8756,8 +8773,8 @@ x_handle_net_wm_state (f, event)
   int value = FULLSCREEN_NONE;
   Lisp_Object lval;
   int sticky = 0;
+  int not_hidden = get_current_wm_state (f, event->window, &value, &sticky);
 
-  get_current_vm_state (f, event->window, &value, &sticky);
   lval = Qnil;
   switch (value) 
     {
@@ -8777,6 +8794,8 @@ x_handle_net_wm_state (f, event)
       
   store_frame_param (f, Qfullscreen, lval);
   store_frame_param (f, Qsticky, sticky ? Qt : Qnil);
+
+  return not_hidden;
 }
 
 /* Check if we need to resize the frame due to a fullscreen request.
@@ -9514,7 +9533,7 @@ x_iconify_frame (f)
   if (!NILP (type))
     x_bitmap_icon (f, type);
 
-#ifdef USE_GTK
+#if defined (USE_GTK)
   if (FRAME_GTK_OUTER_WIDGET (f))
     {
       if (! FRAME_VISIBLE_P (f))
@@ -10545,6 +10564,8 @@ x_term_init (display_name, xrm_option, resource_name)
     = XInternAtom (dpyinfo->display, "_NET_WM_STATE_MAXIMIZED_VERT", False);
   dpyinfo->Xatom_net_wm_state_sticky
     = XInternAtom (dpyinfo->display, "_NET_WM_STATE_STICKY", False);
+  dpyinfo->Xatom_net_wm_state_sticky
+    = XInternAtom (dpyinfo->display, "_NET_WM_STATE_HIDDEN", False);
   dpyinfo->Xatom_net_window_type
     = XInternAtom (dpyinfo->display, "_NET_WM_WINDOW_TYPE", False);
   dpyinfo->Xatom_net_window_type_tooltip
diff --git a/src/xterm.h b/src/xterm.h
index cdfe6493e38..14fa6879f4c 100644
--- a/src/xterm.h
+++ b/src/xterm.h
@@ -365,7 +365,8 @@ struct x_display_info
   /* Atoms dealing with EWMH (i.e. _NET_...) */
   Atom Xatom_net_wm_state, Xatom_net_wm_state_fullscreen_atom,
     Xatom_net_wm_state_maximized_horz, Xatom_net_wm_state_maximized_vert,
-    Xatom_net_wm_state_sticky, Xatom_net_frame_extents;
+    Xatom_net_wm_state_sticky, Xatom_net_wm_state_hidden,
+    Xatom_net_frame_extents;
 
   /* XSettings atoms and windows.  */
   Atom Xatom_xsettings_sel, Xatom_xsettings_prop, Xatom_xsettings_mgr;
