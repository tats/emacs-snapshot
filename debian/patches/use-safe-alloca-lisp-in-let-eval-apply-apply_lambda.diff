* An allocation problem has been fixed in let, eval, apply, and apply_lambda.
  Patch: use-safe-alloca-lisp-in-let-eval-apply-apply_lambda.diff
  Provided-by: Sven Joachim <svenjoac@gmx.de>
  Date: Thu, 19 Aug 2010 21:24:11 +0200
  Added-by: Rob Browning <rlb@defaultvalue.org>
  Status: incorporated upstream

  Previously, the content of the relevant items was invisible to the
  garbage collector.

  The Debian patch is taken from this upstream commit:

  revno: 99983
  committer: Andreas Schwab <schwab@linux-m68k.org>
  branch nick: emacs
  timestamp: Tue 2010-08-17 23:07:50 +0200
  message:
    * eval.c (Flet, Feval, Fapply, apply_lambda): Use SAFE_ALLOCA_LISP
    instead of SAFE_ALLOCA.

--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,3 +1,8 @@
+2010-08-17  Andreas Schwab  <schwab@linux-m68k.org>
+
+	* eval.c (Flet, Feval, Fapply, apply_lambda): Use SAFE_ALLOCA_LISP
+	instead of SAFE_ALLOCA.
+
 2010-08-17  Chong Yidong  <cyd@stupidchicken.com>
 
        * eval.c (Flet, Feval, Fapply, apply_lambda): Use SAFE_ALLOCA
--- a/src/eval.c
+++ b/src/eval.c
@@ -1034,7 +1034,7 @@
 
   /* Make space to hold the values to give the bound variables */
   elt = Flength (varlist);
-  SAFE_ALLOCA (temps, Lisp_Object *, XFASTINT (elt) * sizeof (Lisp_Object));
+  SAFE_ALLOCA_LISP (temps, XFASTINT (elt));
 
   /* Compute the values and store them in `temps' */
 
@@ -2303,8 +2303,7 @@
 	  register int argnum = 0;
 	  USE_SAFE_ALLOCA;
 
-	  SAFE_ALLOCA (vals, Lisp_Object *,
-		       XINT (numargs) * sizeof (Lisp_Object));
+	  SAFE_ALLOCA_LISP (vals, XINT (numargs));
 
 	  GCPRO3 (args_left, fun, fun);
 	  gcpro3.var = vals;
@@ -2476,8 +2475,7 @@
 	{
 	  /* Avoid making funcall cons up a yet another new vector of arguments
 	     by explicitly supplying nil's for optional values */
-	  SAFE_ALLOCA (funcall_args, Lisp_Object *,
-		       (1 + XSUBR (fun)->max_args) * sizeof (Lisp_Object));
+	  SAFE_ALLOCA_LISP (funcall_args, 1 + XSUBR (fun)->max_args);
 	  for (i = numargs; i < XSUBR (fun)->max_args;)
 	    funcall_args[++i] = Qnil;
 	  GCPRO1 (*funcall_args);
@@ -2489,8 +2487,7 @@
      function itself as well as its arguments.  */
   if (!funcall_args)
     {
-      SAFE_ALLOCA (funcall_args, Lisp_Object *,
-		   (1 + numargs) * sizeof (Lisp_Object));
+      SAFE_ALLOCA_LISP (funcall_args, 1 + numargs);
       GCPRO1 (*funcall_args);
       gcpro1.nvars = 1 + numargs;
     }
@@ -3121,8 +3118,7 @@
   USE_SAFE_ALLOCA;
 
   numargs = Flength (args);
-  SAFE_ALLOCA (arg_vector, Lisp_Object *,
-	       XINT (numargs) * sizeof (Lisp_Object));
+  SAFE_ALLOCA_LISP (arg_vector, XINT (numargs));
   args_left = args;
 
   GCPRO3 (*arg_vector, args_left, fun);
